apiVersion: infra.contrib.fluxcd.io/v1alpha2
kind: Terraform
metadata:
  name: {{ .Values.cluster_name }}
  namespace: default
spec:
  dependsOn:
    - name: {{ .Values.network_name }} # IMPORTANT: This must match the name of your VPC/Network Terraform CR

  # Reconcile cadence: plan/apply and drift detection cadence
  interval: 5m

  # Automate plan approval + apply (good for non-prod; for prod consider manual)
  approvePlan: auto

  # Path within the GitRepository that contains your Terraform code
  path: terraform/infrastructure/cluster

  # Reference to the Flux Source
  sourceRef:
    kind: GitRepository
    name: ack-git

  # Runner configuration (multi-tenancy model)
  serviceAccountName: tf-runner-sa
  destroyResourcesOnDeletion: true
  
  # New: write all outputs to a Secret
  writeOutputsToSecret:
    name: {{ .Values.cluster_name }}-outputs
    # (optional) add labels/annotations if another controller consumes the secret
    labels:
      app.kubernetes.io/managed-by: tofu-controller
    annotations:
      example.com/expires-at: "never"

  # Terraform variables (match your variables.tf)
  vars:
    - name: cluster_name
      value: {{ .Values.cluster_name }}

  varsFrom:
    - kind: Secret
      name: {{ .Values.network_name }}-outputs

---
apiVersion: infra.contrib.fluxcd.io/v1alpha2
kind: Terraform
metadata:
  name: {{ .Values.cluster_name }}-tf-token-writer
  namespace: default # Or your Flux namespace
spec:
  destroyResourcesOnDeletion: true
  # This is the most critical part. It tells Flux to wait until
  # the first stage is successfully applied.
  dependsOn:
    - name: {{ .Values.cluster_name }}

  # Reconcile cadence: plan/apply and drift detection cadence
  interval: 5m

  # Automate plan approval + apply (good for non-prod; for prod consider manual)
  approvePlan: auto

  # Path within the GitRepository that contains your Terraform code
  path: terraform/infrastructure/token-writer
  runnerPodTemplate:
    spec:
      image: 810918108393.dkr.ecr.eu-south-1.amazonaws.com/tf-runner-tools:v1

  # Reference to the Flux Source
  sourceRef:
    kind: GitRepository
    name: ack-git

  # Runner configuration (multi-tenancy model)
  serviceAccountName: tf-runner-sa

  # Define all your variables for this stage here
  vars:
    - name: region
      value: "eu-south-1"
    - name: eks_cluster_name
      value: "{{ .Values.cluster_name }}"
    - name: runner_principal_arn
      value: "arn:aws:iam::810918108393:role/eksctl-k8-simulation-nodegroup-def-NodeInstanceRole-WrSOfoyc7m3b"
    - name: remote_target_namespace
      value: "default"
    - name: publish_secret_namespace
      value: "default"

---
apiVersion: infra.contrib.fluxcd.io/v1alpha2
kind: Terraform
metadata:
  name: {{ .Values.cluster_name }}-tf-kubeconfig-builder
  namespace: default # Or your Flux namespace
spec:
  destroyResourcesOnDeletion: true
  # This is the most critical part. It tells Flux to wait until
  # the first stage is successfully applied.
  dependsOn:
    - name: {{ .Values.cluster_name }}-tf-token-writer
  
  # Reconcile cadence: plan/apply and drift detection cadence
  interval: 5m

  # Automate plan approval + apply (good for non-prod; for prod consider manual)
  approvePlan: auto

  # Path within the GitRepository that contains your Terraform code
  path: terraform/infrastructure/kubeconfig-builder
  runnerPodTemplate:
    spec:
      image: 810918108393.dkr.ecr.eu-south-1.amazonaws.com/tf-runner-tools:v1

  # Reference to the Flux Source
  sourceRef:
    kind: GitRepository
    name: ack-git

  # Runner configuration (multi-tenancy model)
  serviceAccountName: tf-runner-sa

  # Define variables for this stage
  vars:
    - name: publish_secret_namespace
      value: "default"
    - name: publish_secret_name
      value: "{{ .Values.cluster_name }}-remote-kubeconfig-secret" # The final secret for your HelmRelease


---
apiVersion: v1
kind: Pod
metadata:
  name: "{{ .Release.Name }}-readiness-test"
  namespace: {{ .Release.Namespace }}
  annotations:
    # This marks the resource as a Helm Test
    "helm.sh/hook": test
    # This tells Helm to delete this pod after a successful test run.
    # If the test fails, the pod is left for debugging.
    "helm.sh/hook-delete-policy": hook-completed,before-hook-creation
spec:
  # --- THIS IS THE KEY CHANGE ---
  # Instead of creating a new ServiceAccount, we use the existing one
  # that the main Terraform resource already uses.
  serviceAccountName: tf-runner-tester # IMPORTANT: Assumes tf-runner-tester is in the same namespace

  # We don't want this test pod hanging around forever.
  restartPolicy: Never
  
  containers:
    - name: checker
      # Using a small, official image that contains the kubectl binary
      image: bitnami/kubectl:latest
      command:
        - "/bin/sh"
        - "-c"
        - |
          echo "--- Waiting for Terraform resource 'terraform/{{ .Values.cluster_name }}-tf-kubeconfig-builder' to become Ready ---"
          
          # This is the core of the test.
          # It waits up to 45 minutes (--timeout=45m) for the 'Ready' condition on the Terraform resource.
          # If the condition is met, the command exits with code 0 (Success).
          # If it times out or fails, it exits with code 1 (Failure).
          kubectl wait --for=condition=Ready terraform/{{ .Values.cluster_name }}-tf-kubeconfig-builder --timeout=45m -n {{ .Release.Namespace }}
          
          if [ $? -eq 0 ]; then
            echo "--- Terraform resource is Ready! Test successful. ---"
            exit 0
          else
            echo "--- Timed out waiting for Terraform resource. Test failed. ---"
            echo "--- Current status of Terraform resource '{{ .Values.cluster_name }}-tf-kubeconfig-builder': ---"
            kubectl get terraform {{ .Values.cluster_name }}-tf-kubeconfig-builder -n {{ .Release.Namespace }} -o yaml
            exit 1
          fi
